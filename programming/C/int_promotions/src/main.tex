\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}


%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% PREAMBLE
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Important styling notes
%%
% For now, to include img.jpg in img/path/to/img.jpg, just use:
% path/to/img.jpg - for details see style.tex
\input{style.tex}




\begin{document}
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% GLOBAL STYLES (DOCUMENT SCOPE)
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% caption: Figure 1 -> <bold> Fig. 1 </bold>
\captionsetup[figure]{labelfont={bf},labelformat={default},labelsep=period,name={Fig.}}


%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% TITLE PAGE
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\input{title.tex}
%\maketitle



%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% MAIN DOCUMENT
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\tableofcontents
\newpage



%------------------------------ New section ------------------------------%
\section{Integer promotions and signed conversions in C}



\subsection{Integer sub-types and ranges}

Integer promotion refers to when sub-types of \texttt{int}, such as \texttt{short} and \texttt{char} are implicitly converted to \texttt{int}. The table below shows the size of \texttt{int} and its sub-types for most 32-bit machines.

\begin{tabular}{p{0.3\textwidth}p{0.1\textwidth}p{0.15\textwidth}p{0.15\textwidth}p{0.15\textwidth}} \toprule % {|p{4cm}|p{5cm}|}
{Types} & {Bits} & {Naming} & {Min} &{Max} \\ \midrule
    \texttt{char (signed char)} & 8 & byte & $-2^7$ & $2^7-1$\\
    \texttt{unsigned char} &  8 & byte &0 & $2^8-1$\\
    \texttt{short (signed short)} &  16 & word & $-2^{15}$ & $2^{15}-1$\\
    \texttt{unsigned short} &  16 & word & 0 & $2^{16}-1$\\
    \texttt{int (signed int)} &  32 & double word & $-2^{31}$ & $2^{31}-1$\\
    \texttt{unsigned short} &  32 & double word & $0$ & $2^{32}-1$\\
    \bottomrule
\end{tabular}

Note that the sizes in the table are common among many systems but not universal. For example, OpenBSD systems use different numbers of bits.


\subsection{Integer promotion example}

% ref https://www.oreilly.com/library/view/c-in-a/0596006977/ch04.html
As we'll see, this happens when we perform arithmetic operations on the sub-types. The second basic rule is that any operand which is sub-type of \texttt{int} is automatically converted to the type \texttt{int} , provided \texttt{int}  is capable of representing all values of the operandâ€™s original type. If \texttt{int}  is not sufficient, the operand is converted to \texttt{unsigned int}.

In the code below, the sub-expression \texttt{c1 * c2 = 400} is promoted to \texttt{int}. The division \texttt{c1 * c2 / c3} also yields an int (40). Since that fits in the \texttt{signed char} range of $[-128, 127]$ \footnote{If it didn't fit in that range, we'd have \emphasis{signed overflow}, which is undefined behaviour in C and wouldn't be able to determine the value of \texttt{res}. If, on the other hand, \texttt{res} was \texttt{unsigned char} and was assigned e.g. $256\notin [0,255]$, we'd have \emphasis{unsigned overflow}. The compiler would map \texttt{256} to \texttt{256 mod UCHAR\_MAX = 256 mod 256 = 0}, $257$ to $1$ etc.}, we have no overflow so it can safely be cast back to \texttt{signed char}. Note that values such as \texttt{10, 100, '('} are also treated as \texttt{int}, therefore take 4 bytes, before being cast to \texttt{char} (1 byte).

\lstinputlisting[language=c,caption={\texttt{char} promotion to int. (\detokenize{src/char_to_int.c)}.}]{src/char_to_int.c}

The disassembly for line 4 shows clearly what happens. \texttt{char c1, c2, c3} are all treated as \texttt{int} and so is the result \texttt{char res = char c1, c2, c3}, which is stored in register \texttt{EAX} after the \texttt{idiv} instruction \footnote{App \TODO describes in detail how instruction \texttt{idiv} works.}. However, because \texttt{res} was declared as \texttt{char} type, we extract only its bottom 8 bits (\texttt{AL} sub-sub register of \texttt{EAX}) and store them back to a local variable.

\begin{verbatim}
; char res = c1 * c2 / c3;
movsx   edx, BYTE PTR [ebp-28]
movsx   eax, BYTE PTR [ebp-32]
imul    eax, edx
movsx   ecx, BYTE PTR [ebp-36]
cdq
idiv    ecx
mov     BYTE PTR [ebp-9], al
\end{verbatim}


\section{Signed and unsigned conversions}


\subsection{Conversion golden rule}

Another problem occurs when we mix \texttt{unsigned} with \texttt{signed} types, e.g. by adding them together. The general integer conversion rule, that holds for short, char, int, either signed or unsigned is:

\begin{adjustwidth}{1cm}{1cm}
%https://www.linkedin.com/pulse/dark-corners-c-integer-arithmetic-akshay-padhye
``In case of operands of different data types, one integer operand (and hence the result) is promoted to the type of other integer operand, if other integer operand can hold larger number.''
\end{adjustwidth}

If the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, the operand with unsigned integer type is converted to the type of the operand with signed integer type.

Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type (\texttt{unsigned short}, \texttt{unsigned int}, etc.).

This rule applies whenever we perform arithmetic or logical operations (for both the left and right side operands), be it $<, \: +, \: ==$, etc.



\subsection{Example of conversions}

Below is a listing that demonstrates the principle. Note that \texttt{printf} was not used much as e.g. trying to print and unsigned integer as signed (\texttt{\%d}) results in undefined behaviour.

\lstinputlisting[language=c,caption={Examples of signed and unsigned type mixing.}]{src/int_conversions.c}

The output is:
\begin{verbatim}
[Ex1]: -5 + 2 > 0
[Ex2]: -5 + 2 < 0
[Ex3]: signed = 0xffffffff, unsigned = 0xff
[Ex4]: signed = 0xffffffff, unsigned = 0xffffffff
[Ex5]: 1 > -1
[Ex 6]: 1
[Ex 7]: 1
[Ex 8]: unsigned char = 255
\end{verbatim}


Let's interpret the results.

\textbf{Example 1}. The summation operands are \texttt{signed int si} and \texttt{unsigned int ui}. Because the latter can express larger numbers, \texttt{si} is converted to unsigned integer by adding to it \texttt{UNSIGNED\_INT\_MAX + 1}. Therefore the result we compare against zero is a very larger number.

\textbf{Example 2}. Since \texttt{(signed) short} can hold larger values than \texttt{unsigned char}, \texttt{uc} is converted to \texttt{short}. Its value is the same as either type so we have no loss of information. Compiling for 32 bits, the disassembly would look essentially like as follows.
\begin{verbatim}
mov     word ptr [ebp - 6], -5
mov     byte ptr [ebp - 7], 2
movsx   ecx, word ptr [ebp - 6]
movzx   edx, byte ptr [ebp - 7]
add     ecx, edx
\end{verbatim}
In the beginning, the values are represented by the sizes corresponding to their types but before the addition they have to be moved to 32 bit registers, hence be zero extended (\texttt{movzx}) or sign extended (\texttt{movsx}). The compiler prefers to directly move the data to the full registers instead of explicitly applying the integer conversion rule, which in this case would be converting them to short integers.

\textbf{Example 3}. In this example, the two \texttt{char}s are converted to a hex value of length 8, i.e. to \texttt{unsigned int} type. \texttt{sc} is \textit{sign extended} (i.e. its leading one is propagated to the higher bits until it fits in 32 bits) and \texttt{uc} is \textit{zero extended} (its leading zero is propagated).

\textbf{Example 4}. In this example, although numerically \texttt{ss} and \texttt{ui} are different, we convert them to \texttt{unsigned int} via the \texttt{printf} function. \texttt{ui} is already \texttt{0xffffffff} in hex therefore no extension is needed and \texttt{ss} is signed-extended to also represent \texttt{0xffffffff} in hex. The result of \texttt{==} would be \texttt{true}.  

\textbf{Example 5}. Here, we have two signed operands. The one that can hold larger values is \texttt{signed int si}. Therefore \texttt{shi} is converted to that type (by sign extension) and it will again represent \texttt{-1}. Since \texttt{-1} fits in the new range, we have no loss of information. 

\textbf{Example 6}. We have two operations -- addition and comparison. Due to integer promotion rules, the intermediate result of \texttt{uc + 100} will be represented as an \texttt{int}. Next, we compare an \texttt{int} to an \texttt{unsigned char}. Therefore the latter type will be converted to the former. \texttt{uc} doesn't lose any information so we compare whether \texttt{300 > 200}.

\textbf{Example 7}. We have a similar comparison but add \texttt{unsigned int 100} to the \texttt{unsigned char} instead. The result of the addition will be represented as \texttt{unsigned int} by \texttt{300}.

\textbf{Example 8}. We convert the representation of \texttt{-1} from \texttt{unsigned char} to \texttt{unsigned int}. \texttt{-1} is represented as \texttt{0xff} (or $255$) as \texttt{unsigned char}. Note that its bit don't change -- they're still \texttt{1111 1111}, only its representation. In the \texttt{printf}, zero extension is performed so it doesn't lose any information.

Regarding the last example, in general, to convert a negative signed to signed we do the following loop:
\begin{verbatim}
while (number < 0) {
    number += MAX_UNSIGNED_INT + 1
}
\end{verbatim}
This does not change the binary representation of the number -- only the way it's interpreted. In binary, negative numbers are represented by \emphasis{2's complement}. For example, on a 4-bit machine, we have the signed
\begin{verbatim}
-2 = 1110b
\end{verbatim}
Adding \texttt{MAX\_UNSIGNED\_INT = 16} does not change the bits of the number. Using the magnitude representation instead of 2's complement, we have
\begin{verbatim}
-2 + MAX_UNSIGNED_INT = 14 = 1110b
\end{verbatim}

These are were basics of how integers are handled by the machine in C.


% https://www.oreilly.com/library/view/c-in-a/0596006977/ch04.html
% https://aticleworld.com/signed-and-unsigned-integers/
% https://github.com/LambdaSchool/CS-Wiki/wiki/Casting-Signed-to-Unsigned-in-C 
% https://embeddedgurus.com/stack-overflow/2009/08/a-tutorial-on-signed-and-unsigned-integers/
% https://aticleworld.com/signed-and-unsigned-integers/
% https://github.com/LambdaSchool/CS-Wiki/wiki/Casting-Signed-to-Unsigned-in-C
% https://embeddedgurus.com/stack-overflow/2009/08/a-tutorial-on-signed-and-unsigned-integers/
% http://www.idryman.org/blog/2012/11/21/integer-promotion/
% https://stackoverflow.com/questions/17312545/type-conversion-unsigned-to-signed-int-char/17312930#17312930
% http://www.idryman.org/blog/2012/11/21/integer-promotion/
% https://pleasestopnamingvulnerabilities.com/integers.html




%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% Appendices
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\appendix

\section{Appendices}

% ------------------------ New appendix ------------------------ %
\newpage
\subsection{\texttt{idiv} and \texttt{imul} instructions}
\label{app:idiv_imul}
\texttt{imul} and \texttt{idiv} instructions are used in assembly to perform multiplication or division with signed integers. \texttt{mul} and \texttt{div} are their respective unsigned instructions. We'll be using Intel IA-32 instructions for convenience. 


\subsubsection{\texttt{imul}}
 

% ref http://www.godevtool.com/TestbugHelp/UseofIMUL.htm
The IMUL instruction takes one, two or three operands. It can be used for byte, word or dword operation. IMUL only works with signed numbers. The result is the correct sign to suit the signs of the multiplicand and the multiplier, therefore the if necessary (e.g. negative) is \textit{sign extended} following the 2's complement rules. The size of the result maybe up to twice of the input size. Therefore when using a user-specified register as the destination (table below), the result is truncated to the register size and it's up to the user to prevent information loss. For 32-bit architectures, the result may be represented with up to 64 bits. Finally, remember that 
\begin{itemize}
    \item 32-bit signed range represents numbers $[-2^{31},2^{31}-1]$,
    \item 32-bit unsigned range represents numbers $[0, 2^{32}-1]$.
\end{itemize}


\lstinputlisting[caption={\texttt{imul} simple demonstration. (\detokenize{src/imul_only.asm)}.}]{src/imul_only.asm}

Note that when the result in EDX:EAX is negative, the whole double register is sign extended, to 64 bits, e.g. when we obtain -20, EDX:EAX stores \texttt{0xffffffff:0xffffffec}.


% 86 intel: https://www.felixcloutier.com/x86/imul
\begin{tabular}{p{0.25\textwidth}p{0.37\textwidth}p{0.3\textwidth}} \toprule % {|p{4cm}|p{5cm}|}
{Syntax} & {Description} & {Types} \\ \midrule
    \texttt{imul src} & {\texttt{EDX:EAX = EAX * src}} & {\texttt{src: r/m32}} \\
    
    \texttt{imul dst, src} & {\texttt{dst = src * dst}} & {\texttt{dst: r32}, \texttt{src:r32/m32}}\\
    \texttt{imul dst, src1, src2} & {\texttt{dst = src1 * src2}} & {\texttt{dst: r32},
    \texttt{src1: r32/m32}, \texttt{src2: val32}} \\ \bottomrule
\end{tabular}



\subsubsection{\texttt{idiv}}
% ref Redefining IMUL and IDIV Are you still reading these subtitles?

% see https://www.felixcloutier.com/x86/idiv
% https://www.aldeid.com/wiki/X86-assembly/Instructions/idiv
Assuming 32-bit architecture, \texttt{idiv src} performs signed division. It divides the 64-bit register pair  \texttt{edx:eax} registers by the source operand \texttt{src} (divisor). It  and stores the result in the the pair \texttt{edx:eax}. It stores the quotient in \texttt{eax} and the remainder in \texttt{edx}. Non-integral results are truncated (chopped) towards 0.
\begin{tabular}{p{0.25\textwidth}p{0.37\textwidth}p{0.3\textwidth}} \toprule % {|p{4cm}|p{5cm}|}
{Syntax} & {Description} & {Types} \\ \midrule
    \texttt{idiv src} & {\texttt{EDX = EDX:EAX \% src},\quad\quad\quad\quad\quad\quad\quad \texttt{EAX = EDX:EAX / src}} & {\texttt{src: r/m32}} \\
    \bottomrule
\end{tabular}

However, we need to be careful before using \texttt{idiv}. Check out the following example.

At line 18, \texttt{edx = 0x20 = 32}. We pollute \texttt{eax} with \texttt{eax = 11 = 0xb} and want to divide by \texttt{ebx = 2}  so the program will try to divide \texttt{edx:eax = 0x200000000b} by \texttt{2} and store the quotient \texttt{0x200000000b/2 = 68719476741} in \texttt{eax}. \marginnote{Always make sure that \texttt{eax} is zero before \texttt{idiv} (or \texttt{div}).}However, $68719476741 > 2^{32}$ so it cannot fit -- the program will receive a \texttt{SIGFPE} (arithmetic exception) signal by the kernel and exit.

% also  https://stackoverflow.com/questions/38416593/why-should-edx-be-0-before-using-the-div-instruction/38416896
\lstinputlisting[caption={\texttt{idiv} demonstration for unsigned division. (\detokenize{src/idiv_wrong1.asm)}.}]{src/idiv_wrong1.asm}


%%%%%%%%%%%%%
% negative idiv
%
% https://stackoverflow.com/questions/27385132/divide-a-negative-with-a-positive
% https://stackoverflow.com/questions/54000965/what-is-signed-divisionidiv-instruction
Let's examine what happens when we divide \texttt{EDX:EAX} by a negative number. 

\lstinputlisting[caption={\texttt{idiv} demonstration for signed division. (\detokenize{src/idiv_wrong2.asm)}.}]{src/idiv_wrong2.asm}

In the first example, we attempt to divide $-21$ by $2$ so we move $-21$ to \texttt{eax}, which is represented in hex as \texttt{eax = 0xffffffeb}. \texttt{edx} is zero so \texttt{idiv} will try to define the positive number (leading 0) in \texttt{edx:eax = 00000000:ffffffeb = 4294967275}. As a result, $4294967275$ will be divided by 2, writing \texttt{4294967275 div 2} = \texttt{2147483637} to \texttt{eax} and \texttt{4294967275 mod 2 = 1} to \texttt{edx}.

To get the value right, we need to ensure the whole divident (\texttt{edx:eax}) is negative. This is done by sign extending \texttt{edx} into \texttt{eax}, i.e. set \texttt{edx = 0xffffffff} is \texttt{eax < 0}. Example 2 correctly performs the division, writing \texttt{0xffffffff} (-1) to \texttt{edx} and \texttt{0xfffffff6} (-10) to \texttt{eax}. 

The next section describes an instruction that can generalise this zero/sign extension before \texttt{idiv}.



\subsubsection{The \texttt{cdq} instruction}

% see https://stackoverflow.com/a/25489305
\texttt{cdq} converts the doubleword (32 bits) in \texttt{EAX} into a quadword in \texttt{EDX:EAX} by sign-extending \texttt{EAX}  into \texttt{EDX} (i.e. each bit of EDX is filled with the most significant bit of EAX). 

For example, if \texttt{EAX}  contained \texttt{0x7FFFFFFF} we'd get 0 in \texttt{EDX}, since the most significant bit of \texttt{EAX} is clear. But if we had \texttt{EAX = 0x80000000} we'd get \texttt{EDX = 0xFFFFFFFF} since the most significant bit of \texttt{EAX} is set. The point of \texttt{cdq} is to set up \texttt{EDX} prior to a division by a 32-bit operand, since the dividend is \texttt{EDX:EAX}. 

The program below demonstrates the instruction.

\lstinputlisting[caption={Chaining \texttt{cdg} with \texttt{idiv} to avoid potential arithmetic errors due to sign. (\detokenize{src/idiv_correct.asm)}.}]{src/idiv_correct.asm}

After line 16, \texttt{edx = 0x2} and \texttt{eax = 0x5}. After line 21, \texttt{edx = 0xffffffff} and \texttt{eax = 0xffffffea}. After line 22, \texttt{edx = 0xfffffffe = -2} and \texttt{eax = 0xffffffbf = -5}.





% https://www.cs.virginia.edu/~evans/cs216/guides/x86.html
% Redefining IMUL and IDIV Are you still reading these subtitles?


%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
% References
%=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
\newpage
\printbibliography


\end{document}